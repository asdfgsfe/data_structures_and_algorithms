//方法三：递归（翻转变体）
//思路和算法
//就像在 方法二 中那样，我们可以尝试按它前面的位来写出这一位。
//如果我们写出该序列中的几行，就可以发现：后半部分总是与前半部分相反，也就是说：'0' 变成 '1' 而 '1' 变成 '0'。
//我们可以用归纳法来验证这一推断。其关键思想是，如果字符串X生成Y，那么翻转后的字符串X1将会生成Y1 
//这就引出了下面的算法思想：如果 K 在后半部分，
//那么我们可以将 K -= (1 << N-2) 设为前半部分，然后翻转得到最终答案。
//1 << n - 2表示当前行的一半个数 (1<<n-1) / 2 =  1 << n - 2 满二叉树每层节点数1<<n-1个
//如果k位于左半部分 则f(n, k) = f(n - 1, k)
//如果位于右半部分，则f(n, k) = f(n - 1, k -= (1 << n - 1)) ^ 1

//递归 剪枝算法 节约空间节约时间
class Solution {
public:
	int kthGrammar(int N, int K) {
        if (N == 1) 
		{
			return 0;
		}
		if (k <= (1 << n - 2))
		{
			return kthGrammar(n - 1, K);
		}
        return kthGrammar(n - 1, K - (1 << n - 2)) ^ 1;
    }
};
//复杂度分析
//时间复杂度：O(N)。找出答案需要 N-1N−1 步。
//空间复杂度：O(1)。 

//时间复杂duO(N*k) 空间复杂度o(n*k)
//理解剪枝与动态规划的区别 必然过不了 被空间限制
class Solution {
public:
	int kthGrammar(int N, int K) {
        if (N == 1) 
		{
			return 0;
		}
		vecor<int> dp(N + 1, vector<int>(K + 1, 1));
		for (int i = 2; i < dp.size(); ++i)
		{
			for (int j = 1; j < dp[0].size(); ++j)
			{
				if (j <= (1 << i - 2))
				{
					dp[i][j] = dp[i - 1][j];
				}
				dp[i][j] = j <= (1 << i - 2) ? dp[i - 1][j] : dp[i - 1][j - (1 << i - 2)] ^ 1;
			}
		}
		return dp[N][K];
    }
};


//logN解法
//方法四： Binary Count
//思路和算法
//同方法三一样，每一行的后半部分都是前半部分的翻转。
//把下标 K 写成二进制的形式，如果 K 在第二部分，那么二进制形式的第一个比特位一定是 1。
//据此可以将方法三继续简化，实际上翻转的次数等于 K-1 二进制表示形式中 1 出现的个数。
//当索引 K 写为二进制形式后（从 0 开始索引），后半部分的索引的第一位总是 1。
//这意味着，当使用方法三中的算法时，我们翻转最终答案的次数仅仅是 K-1 的二进制表示中的 1 的个数。
class Solution {
    public int kthGrammar(int N, int K) {
        return Integer.bitCount(K - 1) % 2; //bitCount(n)统计1出现的次数
    }
}
//复杂度分析
//时间复杂度：O(log N)，其为 N 的二进制字符串表示形式的长度。
//空间复杂度：O(1)。
