//有序队列
//给出了一个由小写字母组成的字符串 S。然后，我们可以进行任意次数的移动。
//在每次移动中，我们选择前 K 个字母中的一个（从左侧开始），将其从原位置移除，并放置在字符串的末尾。
//返回我们在任意次数的移动之后可以拥有的按字典顺序排列的最小字符串。
//示例 1：

//输入：S = "cba", K = 1
//输出："acb"
//解释：
//在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。
//在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。
//示例 2：

//输入：S = "baaca", K = 3
//输出："aaabc"
//1 <= K <= S.length <= 1000
//S 只由小写字母组成。

//解题思路:
//当K==1时，元素间相对位置无法变动，求出循环移动过程中的最小字典顺序的字符串，即比较length种情况下最小的字典顺序
//K>=2时，元素间相对位置可以变动，此时类似于bubble sort，为题直接转换为对字符串中元素从小到大顺序进行排序
//感觉是个贪心算法 只要能证明这种操作中任意一个字符可以出现在任意一个位置 或者k>=2时 可以交换无限次
class Solution {
public:
    string orderlyQueue(string S, int K) {
        if(K >= 2)
        {
            std::sort(S.begin(), S.end());
            return S;
        }
        string min = S;
        for(int i = 0; i < S.size(); ++i)
        {
            char cur = S[0];
            for (int j = 0; j + 1 < S.size(); ++j)
            {
                S[j] = S[j + 1];
            }
            S[S.size() - 1] = cur;
            min = std::min(S, min);
        }
        return min;
    }
};