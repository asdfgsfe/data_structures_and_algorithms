class Solution {
public:
    int maxCoins(vector<int>& nums) {
        if (nums.empty())
        {
            return 0;
        }
        vector<vector<int>> dp(nums.size() + 2, vector<int>(nums.size() + 2, 0));
        for (int i = dp.size() - 2; i >= 0; --i)
        {
            for (int j = i + 2; j < dp[0].size(); ++j)
            {
                for (int k = i + 1; k < j; ++k)
                {
                    int coin = (i < nums.size() ? nums[i] : 1) * 
                               (k < nums.size() ? nums[k] : 1) * 
                               (j < nums.size() ? nums[j] : 1);
                    dp[i][j] = std::max(dp[i][j], dp[i][k] + dp[k][j] + coin);
                }
            }
        }
        return dp[0][dp[0].size() - 1];
    }
};

//dp[i][j] = std::max(dp[i][j], dp[i][k] + dp[k][j] + num[i] * num[k] * num[j]);
//dp[i][j]表示全部戳破(i, j]之间气球所能得到的最大值 所以dp多余分配了了两个格子
//设[i,k,j]由于戳破k 会导致k-1与k+1相邻 导致子问题互相依赖 则只能戳破[i-1, k - 1]和[k +1, j - 1]之间的气球
//这就就只剩余i,j,k三个气球 coin为num[i] * num[k] * num[j])
//k的取值范围(i, j) 但是如果j-i=1表示两者之间只有无气球可以戳破 则取值为0 作为dp初始状态

//参考
//在使用分治法时，我们应该考虑的核心问题是如何用子问题的解来表示原问题的解，
//也就是子问题该如何划分才能通过子问题来求解原问题。
//我们把描述子问题的解与原问题的解之间的关系的表达式称为状态转移方程。
　　//首先我们尝试每戳破一个气球，以该气球为边界将气球数组分为两部分，使用这两部分的解来求解原问题。
　　//我们设戳破区间 i 到 j 间的气球我们得到的最大金币数为coin。及coin = def( i , j )。
　　//则当我们戳破气球 k 时，两边区间的最大值分别是 def( i , k-1 ) 与 def( k+1 , j )。
　　//此时我们发现了问题，因为戳破了气球 k ，气球数组的相邻关系发生了改变，k-1 与 k+1 原本都与 k 相邻，
	//而 k 戳破后他们两个直接相邻了。而且先戳破 k+1 与先戳破 k-1 得到的结果将完全不同，
	//也就是说两个子问题间发生了依赖。如果先戳破 k-1 ，则 k+1 左边的相邻气球变成了 k-2；
	//反之 k-1 右边相邻的气球变成了 k+2 。
　　//子问题的处理顺序将影响到每个子问题的解，这将使我们的状态转移方程极为复杂和低效，
	//我们应当换一种划分子问题的方式，使每个子问题都是独立的。
　　//那么我们换一种划分方式，既然两个子问题都依赖 k 和两个边界，那么我们划分子问题时，
//k 与两个边界的气球我们都不戳破，求出 i+1 到 k-1 与 k+1 到 j-1 之间的解。
//这样两个子问题间的依赖便被消除了，两个边界及气球 k 不被戳破，
//两个子问题的依赖都不会越过 k 到另一个子问题上，子问题间是相互独立的。
　　//并且在两个子问题解决后，气球序列还剩下 k 与两个边界的气球没有戳破，
//那么我们用两个子问题的解与戳破 k 与两个边界的最大值即可求出原问题的解。
　　//那么 def( i , j ) 函数的定义则为，不戳破 i 与 j ，仅戳破 i 与 j 之间的气球我们能得到的最大金币数。
　　//如此划分，状态转移方程为： def( i, j ) = def( i , k ) + def( k , j )+nums[ i ][ j ][ k ]
　　//其中 nums[ i ][ j ][ k ] 为戳破气球 k 时我们能得到的金币数，因为def( i , j )表示戳破 i 到 j 之间的气球，自然包括 k 。
　　//上述方程其实还有问题，前面说过，为了保证我们可以完整的搜索解空间，
//我们需要尝试所有的子问题划分方式，对于上述状态转移方程，也就是 k 的取值。
//k 的取值应当介于 i+1 与 j-1 之间，我们尝试所有 k 的取值并从中挑选最大值，这才是原问题真正的解。
　　//真正的状态转移方程应该为：def( i, j ) = max { def( i , k ) + def( k , j )+nums[ i ][ j ][ k ] } | i<k<j
　　//这样我们便找到了用子问题的解来表示原问题的解的方法，或者说子问题的划分方式。
//因为我们要划分子问题，必然不是只划分一次这么简单。而是要把问题一直划分到不能继续划分，也就是划分到问题规模最小的最小子问题，使效率最大化。
　　//因为 k 是介于 i 与 j 之间的，那么当 i 与 j 相邻时我们的问题将不能再继续划分。
//此时按照我们对问题的定义，“不戳破 i 与 j ，仅戳破 i 与 j 之间的气球”，
//因为 i 与 j 之间没有气球，我们得到的金币数是 0 。
　　//为了保证问题定义的正确性，我们向上推演一次。
//def( i , i+2 ) = def( i , i+1 ) + def( i+1 , i+2 ) + nums[i]*nums[ i+1]*nums[i+2]
　　//def( i , i+1 ) , def( i+1 , i+2 ) 都是最小子问题，返回0。
//即 def( i , i+2 ) = nums[i]*nums[ i+1]*nums[i+2] 。因为问题的定义我们不戳破 i 与 i+2，所以我们只能戳破 i+1，戳破 i+1得到的金币确实是 nums[i]*nums[ i+1]*nums[i+2] 即 def( i , i+2 ) 。
　　//所以说对于我们的状态转移方程 
//def( i, j ) = max { def( i , k ) + def( k , j )+nums[ i ][ j ][ k ] } | i<k<j ，
//回归条件 def( i , i+1 ) = 0 是正确的。

//链接：https://leetcode-cn.com/problems/burst-balloons/solution/chao-xiang-xi-hui-su-dao-fen-zhi-dao-dp-by-niu-you/
